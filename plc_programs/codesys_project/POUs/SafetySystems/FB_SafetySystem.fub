FUNCTION_BLOCK FB_SafetySystem
VAR_INPUT
    System_Enable       : BOOL;         // System enable request
    Manual_Reset        : BOOL;         // Manual safety reset
    Bypass_Mode         : BOOL := FALSE; // Safety bypass mode (maintenance only)
END_VAR

VAR_OUTPUT
    Safety_OK           : BOOL;         // Safety system OK
    Emergency_Stop      : BOOL;         // Emergency stop active
    Reset_Required      : BOOL;         // Safety reset required
    System_Safe         : BOOL;         // System safe to operate
    Fault_Code          : INT;          // Safety fault code
END_VAR

VAR
    (* Safety input monitoring *)
    E_Stop_Status       : BOOL;         // Emergency stop button status
    Manual_Reset_Status : BOOL;         // Manual reset button status
    Gate_Closed         : BOOL;         // Safety gate closed
    Light_Curtain_OK    : BOOL;         // Light curtain clear
    
    (* Safety timers *)
    Reset_Timer         : TON;          // Safety reset timer
    Fault_Timer         : TON;          // Fault detection timer
    Startup_Timer       : TON;          // System startup delay timer
    
    (* Safety state machine *)
    Safety_State        : INT := 0;     // Safety state
    
    (* Edge detection *)
    Reset_Edge          : R_TRIG;       // Manual reset edge
    E_Stop_Edge         : F_TRIG;       // E-stop falling edge
    
    (* Parameters *)
    Reset_Time          : TIME := T#3s;  // Safety reset time
    Startup_Delay       : TIME := T#2s;  // Startup delay
    Fault_Detection_Time : TIME := T#1s; // Fault detection time
    
    (* Internal variables *)
    Previous_Safety_OK  : BOOL;         // Previous safety OK state
    Fault_Detected      : BOOL;         // Safety fault detected
END_VAR

(* Read safety inputs *)
E_Stop_Status := NOT GVL_IO.Emergency_Stop;  (* E-stop is normally closed *)
Manual_Reset_Status := GVL_IO.Manual_Reset;
Gate_Closed := GVL_Internal.Safety_Gate_Closed;
Light_Curtain_OK := GVL_Internal.Light_Curtain_Clear;

(* Edge detection *)
Reset_Edge(CLK := Manual_Reset OR Manual_Reset_Status);
E_Stop_Edge(CLK := E_Stop_Status);

(* Safety state machine *)
CASE Safety_State OF
    
    0: (* SAFETY_FAULT *)
        Safety_OK := FALSE;
        Emergency_Stop := TRUE;
        Reset_Required := TRUE;
        System_Safe := FALSE;
        
        (* Output safety signals *)
        GVL_IO.Safety_OK := FALSE;
        GVL_IO.System_Running := FALSE;
        GVL_IO.System_Error := TRUE;
        
        (* Check for reset conditions *)
        IF Reset_Edge.Q AND E_Stop_Status AND Gate_Closed AND (Light_Curtain_OK OR Bypass_Mode) THEN
            Safety_State := 1; (* Move to reset state *)
            Reset_Timer(IN := TRUE, PT := Reset_Time);
            Fault_Code := 0;
        END_IF
    
    1: (* SAFETY_RESETTING *)
        Emergency_Stop := FALSE;
        Reset_Required := FALSE;
        System_Safe := FALSE;
        
        (* Reset timer *)
        Reset_Timer(IN := TRUE, PT := Reset_Time);
        
        (* Check if any safety condition fails during reset *)
        IF NOT E_Stop_Status OR NOT Gate_Closed OR (NOT Light_Curtain_OK AND NOT Bypass_Mode) THEN
            Safety_State := 0; (* Return to fault *)
            Reset_Timer(IN := FALSE);
            Fault_Code := 1; (* Reset interrupted *)
        ELSIF Reset_Timer.Q THEN
            Safety_State := 2; (* Move to startup *)
            Reset_Timer(IN := FALSE);
            Startup_Timer(IN := TRUE, PT := Startup_Delay);
        END_IF
    
    2: (* SAFETY_STARTUP *)
        Emergency_Stop := FALSE;
        Reset_Required := FALSE;
        System_Safe := FALSE;
        
        (* Startup delay timer *)
        Startup_Timer(IN := TRUE, PT := Startup_Delay);
        
        (* Check safety conditions during startup *)
        IF NOT E_Stop_Status OR NOT Gate_Closed OR (NOT Light_Curtain_OK AND NOT Bypass_Mode) THEN
            Safety_State := 0; (* Return to fault *)
            Startup_Timer(IN := FALSE);
            Fault_Code := 2; (* Safety fault during startup *)
        ELSIF Startup_Timer.Q THEN
            Safety_State := 3; (* Move to OK *)
            Startup_Timer(IN := FALSE);
        END_IF
    
    3: (* SAFETY_OK *)
        Safety_OK := TRUE;
        Emergency_Stop := FALSE;
        Reset_Required := FALSE;
        System_Safe := TRUE;
        
        (* Output safety signals *)
        GVL_IO.Safety_OK := TRUE;
        GVL_IO.System_Error := FALSE;
        
        (* Monitor safety conditions *)
        IF NOT E_Stop_Status THEN
            Safety_State := 0;
            Fault_Code := 10; (* Emergency stop activated *)
        ELSIF NOT Gate_Closed THEN
            Safety_State := 0;
            Fault_Code := 11; (* Safety gate open *)
        ELSIF NOT Light_Curtain_OK AND NOT Bypass_Mode THEN
            Safety_State := 0;
            Fault_Code := 12; (* Light curtain interrupted *)
        END_IF

END_CASE

(* Fault detection for safety system integrity *)
Fault_Timer(IN := Safety_OK AND NOT Previous_Safety_OK, PT := Fault_Detection_Time);
Previous_Safety_OK := Safety_OK;

(* Update global safety status *)
GVL_Internal.Safety_Circuit_OK := Safety_OK;
GVL_Internal.Emergency_Stop_Active := Emergency_Stop;
GVL_Internal.Safety_Reset_Required := Reset_Required;